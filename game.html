<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Rizznake - Game On!</title>
<meta name="description" content="Play Rizznake with your chosen character. Retro snake game with personality!">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="author" content="Radhin">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
<style>
:root {
--bg-color: #0c140c;
--screen-color: #162316;
--snake-body: #c0e0c0;
--snake-head-dash: #e5c53d;
--snake-head-vasu: #a83636;
--snake-head-sayip: #3d6cb5;
--food-color: #aaffaa;
--text-color: #c0f0c0;
--border-color: #253325;
--glow: rgba(0, 200, 0, 0.5);
}
* { box-sizing: border-box; touch-action: manipulation; }
body {
background: var(--bg-color);
color: var(--text-color);
font-family: 'Press Start 2P', monospace;
overflow: hidden;
min-height: 100vh;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
padding: 15px;
position: relative;
/* CRT Scanlines */
background-image:
linear-gradient(rgba(0, 25, 0, 0.1) 50%, transparent 50%),
linear-gradient(90deg, rgba(0, 25, 0, 0.1) 50%, transparent 50%);
background-size: 3px 3px;
touch-action: none;
overscroll-behavior: none;
}
.player-display {
background: rgba(0,0,0,0.4);
padding: 6px 12px;
border-radius: 4px;
margin-bottom: 10px;
font-size: 13px;
border: 1px solid var(--border-color);
width: 100%;
max-width: 450px;
text-align: center;
}
.player-display span { color: #aaffaa; }
.page-header {
display: flex;
justify-content: space-between;
width: 100%;
max-width: 500px;
margin-bottom: 10px;
}
.back-btn {
background: var(--screen-color);
color: var(--text-color);
border: 2px solid var(--border-color);
padding: 6px 12px;
font-family: inherit;
font-size: 13px;
cursor: pointer;
text-transform: uppercase;
box-shadow: 2px 2px 0 var(--border-color);
text-decoration: none;
border-radius: 4px;
}
.back-btn:active {
transform: translate(2px, 2px);
box-shadow: 0 0 0 var(--border-color);
}
.game-wrapper {
position: relative;
border: 6px solid var(--border-color);
background-color: var(--screen-color);
box-shadow: 0 8px 20px rgba(0,0,0,0.5),
inset 0 0 12px rgba(0,0,0,0.4);
max-width: 100%;
width: 450px;
border-radius: 4px;
}
.board {
position: relative;
width: 100%;
aspect-ratio: 1.25 / 1;
max-height: 360px;
}
.cell {
position: absolute;
background: transparent;
}
.cell.snake {
background-color: var(--snake-body);
border-radius: 2px;
}
.cell.snake.head {
border-radius: 2px;
overflow: hidden;
}
.cell.food {
background-color: var(--food-color);
border-radius: 50%;
box-shadow: 0 0 8px rgba(170, 255, 170, 0.8);
animation: pulse 1s infinite;
}
@keyframes pulse {
0%, 100% { transform: scale(0.8); opacity: 0.7; }
50% { transform: scale(1.1); opacity: 1; }
}
.hud {
display: flex;
justify-content: space-between;
width: 100%;
max-width: 450px;
font-size: 15px;
margin-bottom: 12px;
background: rgba(0,0,0,0.25);
padding: 6px 12px;
border-radius: 4px;
border: 1px solid var(--border-color);
}
#game-overlay {
position: absolute; top: 0; left: 0; width: 100%; height: 100%;
background: rgba(12, 20, 12, 0.95);
display: flex; flex-direction: column; justify-content: center; align-items: center;
z-index: 10;
padding: 20px;
text-align: center;
border-radius: 4px;
}
.overlay-btns {
display: flex;
gap: 12px;
margin-top: 20px;
width: 100%;
justify-content: center;
flex-wrap: wrap;
}
.game-btn {
background: var(--screen-color);
color: var(--text-color);
border: 2px solid var(--border-color);
padding: 8px 16px;
margin: 0 5px;
font-family: inherit;
font-size: 13px;
cursor: pointer;
text-transform: uppercase;
box-shadow: 2px 2px 0 var(--border-color);
border-radius: 4px;
min-width: 110px;
}
.game-btn:active {
transform: translate(2px, 2px);
box-shadow: 0 0 0 var(--border-color);
}
.watermark {
position: absolute;
bottom: 12px;
left: 50%;
transform: translateX(-50%);
font-size: 11px;
opacity: 0.5;
}
.mute-btn {
position: absolute;
top: 70px;
right: 15px;
font-size: 18px;
cursor: pointer;
opacity: 0.8;
z-index: 5;
}
.mute-btn:hover { opacity: 1; }
.controls-info {
font-size: 11px;
opacity: 0.7;
margin-top: 12px;
text-align: center;
max-width: 450px;
}
.hidden { display: none !important; }
.game-title {
font-size: 22px;
margin: 8px 0;
text-align: center;
text-shadow: 0 0 4px var(--glow);
}
</style>
</head>
<body>
<div class="page-header">
<a href="index.html" class="back-btn">‚Üê MENU</a>
<div class="mute-btn" id="muteBtn">üîä</div>
</div>
<div class="player-display">
PLAYER: <span id="playerNameDisplay">Loading...</span>
</div>
<h2 class="game-title">RIZZNAKE</h2>
<div class="hud">
<span>SCORE: <span id="scoreVal">0</span></span>
<span>BEST: <span id="bestVal">0</span></span>
</div>
<div class="game-wrapper">
<div id="board" class="board"></div>
<div id="game-overlay" class="hidden">
<h2>GAME OVER</h2>
<div style="margin: 15px 0; font-size: 14px;">
Your score: <span id="finalScore">0</span>
</div>
<div class="overlay-btns">
<button class="game-btn" onclick="resetGame()">RESTART</button>
<button class="game-btn" onclick="location.href='index.html'">MENU</button>
</div>
</div>
</div>
<div class="controls-info">
Use Arrow Keys or Swipe to Control the Snake
</div>
<div class="watermark">Rizznake ¬© Radhin</div>
<script>
// Firebase
const firebaseConfig = {
apiKey: "AIzaSyCaa9IHlcKGdUEZjf0BpdBEFUB8KoppVP0",
authDomain: "rizznake-2cc02.firebaseapp.com",
projectId: "rizznake-2cc02",
storageBucket: "rizznake-2cc02.firebasestorage.app",
messagingSenderId: "176358385186",
appId: "1:176358385186:web:68c6c662895eb512034c7b"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// Config
const GRID_W = 20;
const GRID_H = 16;
const BASE_SPEED = 130;

const characters = [
{ name: "Dashamoolam", color: "char-0", eatFreq: 600, dieFreq: 150, image: "dashamoolam.jpg" },
{ name: "Vasu", color: "char-1", eatFreq: 800, dieFreq: 120, image: "vasu.jpg" },
{ name: "Sayip", color: "char-2", eatFreq: 1000, dieFreq: 100, image: "sayip.jpg" }
];

// State
let gameState = {
snake: [],
dir: {x:0, y:-1},
nextDir: {x:0, y:-1},
food: {x:0,y:0},
score: 0,
bestScore: 0,
charIdx: 0,
playerId: '',
playerName: 'Anonymous',
running: false,
muted: false,
cellElements: [],
boardEl: null,
lastTime: 0
};

let audioCtx = null;

// Init
function init() {
const urlParams = new URLSearchParams(window.location.search);
gameState.charIdx = parseInt(urlParams.get('char')) || 0;
gameState.playerName = urlParams.get('name') || 'Guest';
gameState.playerId = urlParams.get('id') || 'anonymous_' + Date.now();

document.getElementById('playerNameDisplay').textContent = gameState.playerName;
gameState.boardEl = document.getElementById('board');
setupBoardDOM();
bindEvents();
loadScores();
loadMuteState();
resetGame();
}

function setupBoardDOM() {
gameState.cellElements = [];
const board = gameState.boardEl;
board.innerHTML = '';
for (let y = 0; y < GRID_H; y++) {
for (let x = 0; x < GRID_W; x++) {
const cell = document.createElement('div');
cell.className = 'cell';
cell.style.left = (x * (100/GRID_W)) + '%';
cell.style.top = (y * (100/GRID_H)) + '%';
cell.style.width = (100/GRID_W) + '%';
cell.style.height = (100/GRID_H) + '%';
board.appendChild(cell);
gameState.cellElements.push(cell);
}
}
}

function getIndex(x, y) {
return y * GRID_W + x;
}

// Audio
function play(freq, duration = 0.1, type = 'sine', volume = 0.1) {
if (gameState.muted || typeof AudioContext === 'undefined') return;
try {
if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
if (audioCtx.state === 'suspended') audioCtx.resume();
const osc = audioCtx.createOscillator();
const gain = audioCtx.createGain();
osc.type = type;
osc.frequency.value = freq;
gain.gain.value = volume;
gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
osc.connect(gain);
gain.connect(audioCtx.destination);
osc.start();
osc.stop(audioCtx.currentTime + duration);
} catch(e) {}
}

function playEat() {
const char = characters[gameState.charIdx];
play(char.eatFreq, 0.1, 'sine', 0.2);
}
function playDie() {
const char = characters[gameState.charIdx];
play(char.dieFreq, 0.5, 'sawtooth', 0.3);
}

// Unified Scores (no per-character separation)
function loadScores() {
// Load global best score (across all characters)
const savedBest = localStorage.getItem('rizznake_best_global');
gameState.bestScore = savedBest ? parseInt(savedBest) : 0;
document.getElementById('bestVal').textContent = gameState.bestScore;
}

// Unified score saving (global best, one entry per player)
async function saveScore() {
    // Only submit if it's a new personal best
    if (gameState.score <= gameState.bestScore) {
        return;
    }

    // Update local best (global across all characters)
    gameState.bestScore = gameState.score;
    localStorage.setItem('rizznake_best_global', gameState.bestScore);
    document.getElementById('bestVal').textContent = gameState.bestScore;

    try {
        // 1. Check if player already has a score doc
        const existingSnapshot = await db.collection('scores')
            .where('playerId', '==', gameState.playerId)
            .limit(1)
            .get();

        if (!existingSnapshot.empty) {
            // 2. If exists, get the doc and compare scores
            const existingDoc = existingSnapshot.docs[0];
            const existingData = existingDoc.data();

            if (gameState.score > existingData.score) {
                // Only update if new score is higher
                await existingDoc.ref.update({
                    score: gameState.score,
                    character: gameState.charIdx,
                    characterName: characters[gameState.charIdx].name,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log("Score updated!");
            }
        } else {
            // 3. If no existing score, create new one
            await db.collection('scores').add({
                name: gameState.playerName,
                playerId: gameState.playerId,
                score: gameState.score,
                character: gameState.charIdx,
                characterName: characters[gameState.charIdx].name,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log("New score submitted!");
        }

        // 4. ‚úÖ TRIGGER LEADERBOARD REFRESH in index1.html on next visit
        // (We'll auto-reload when returning to home)

    } catch (e) {
        console.error("Score save failed:", e);
        alert("Score saved locally. Leaderboard may not update.");
    }
}

// Update local best score (global, not per character)
gameState.bestScore = gameState.score;
localStorage.setItem('rizznake_best_global', gameState.bestScore);
document.getElementById('bestVal').textContent = gameState.bestScore;

// Submit to database
await submitScore();
}

async function submitScore() {
try {
// Check if player already has a score in the database
const existingScores = await db.collection('scores')
.where('playerId', '==', gameState.playerId)
.get();

let needsUpdate = false;
let highestScoreDoc = null;
let highestScore = 0;

// Find the highest score document for this player
existingScores.docs.forEach(doc => {
const data = doc.data();
if (data.score > highestScore) {
highestScore = data.score;
highestScoreDoc = doc;
}
});

// If they have no scores yet, or this score is higher than their best
if (existingScores.empty || gameState.score > highestScore) {
// If they already have scores but this is higher, delete the old ones
if (!existingScores.empty && highestScoreDoc) {
const batch = db.batch();
existingScores.docs.forEach(doc => {
batch.delete(doc.ref);
});
await batch.commit();
}

// Create new score document
await db.collection('scores').add({
name: gameState.playerName,
playerId: gameState.playerId,
score: gameState.score,
character: gameState.charIdx,
characterName: characters[gameState.charIdx].name,
timestamp: firebase.firestore.FieldValue.serverTimestamp()
});
console.log("Score submitted successfully!");
}
} catch (e) {
console.error("Score submit failed:", e);
}
}

// Game Logic
function resetGame() {
setupBoardDOM();
gameState.snake = [{x:10,y:8}, {x:10,y:9}, {x:10,y:10}];
gameState.dir = {x:0, y:-1};
gameState.nextDir = {x:0, y:-1};
gameState.score = 0;
document.getElementById('scoreVal').textContent = '0';
gameState.running = true;
document.getElementById('game-overlay').classList.add('hidden');
placeFood();
requestAnimationFrame(gameLoop);
}

function placeFood() {
let x, y;
do {
x = Math.floor(Math.random() * GRID_W);
y = Math.floor(Math.random() * GRID_H);
} while (gameState.snake.some(s => s.x === x && s.y === y));
gameState.food = {x, y};
}

function gameLoop(ts) {
if (!gameState.running) return;
requestAnimationFrame(gameLoop);
const now = ts || performance.now();
if (!gameState.lastTime) gameState.lastTime = now;
if (now - gameState.lastTime < BASE_SPEED) return;
gameState.lastTime = now;
update();
render();
}

function update() {
if (gameState.nextDir.x !== -gameState.dir.x || gameState.nextDir.y !== -gameState.dir.y) {
gameState.dir = {...gameState.nextDir};
}

const head = gameState.snake[0];
const newHead = {
x: head.x + gameState.dir.x,
y: head.y + gameState.dir.y
};

if (newHead.x < 0 || newHead.x >= GRID_W || newHead.y < 0 || newHead.y >= GRID_H) {
endGame(); return;
}

if (gameState.snake.some(s => s.x === newHead.x && s.y === newHead.y)) {
endGame(); return;
}

gameState.snake.unshift(newHead);

if (newHead.x === gameState.food.x && newHead.y === gameState.food.y) {
gameState.score += 10;
document.getElementById('scoreVal').textContent = gameState.score;
playEat();
placeFood();
} else {
gameState.snake.pop();
}
}

function render() {
for (let el of gameState.cellElements) {
el.className = 'cell';
el.innerHTML = '';
}

const foodIdx = getIndex(gameState.food.x, gameState.food.y);
gameState.cellElements[foodIdx].classList.add('food');

for (let i = 1; i < gameState.snake.length; i++) {
const seg = gameState.snake[i];
const idx = getIndex(seg.x, seg.y);
gameState.cellElements[idx].classList.add('snake');
}

const head = gameState.snake[0];
const headIdx = getIndex(head.x, head.y);
const headCell = gameState.cellElements[headIdx];
headCell.classList.add('snake', 'head');

const img = document.createElement('img');
img.src = characters[gameState.charIdx].image;
img.alt = characters[gameState.charIdx].name;
img.style.width = '100%';
img.style.height = '100%';
img.style.objectFit = 'cover';
img.style.display = 'block';

img.onerror = function() {
this.style.display = 'none';
headCell.style.backgroundColor = characters[gameState.charIdx].color === 'char-0' ? '#e5c53d' :
characters[gameState.charIdx].color === 'char-1' ? '#a83636' : '#3d6cb5';
headCell.style.borderRadius = '2px';
};

headCell.appendChild(img);
}

function endGame() {
gameState.running = false;
playDie();

// Show final score
document.getElementById('finalScore').textContent = gameState.score;

// Save score (unified system)
saveScore();

// Show game over screen
document.getElementById('game-overlay').classList.remove('hidden');
}

// Input
function handleKey(e) {
if (!gameState.running) return;
const key = e.key;
if (key === 'ArrowUp' && gameState.dir.y === 0) gameState.nextDir = {x:0, y:-1};
if (key === 'ArrowDown' && gameState.dir.y === 0) gameState.nextDir = {x:0, y:1};
if (key === 'ArrowLeft' && gameState.dir.x === 0) gameState.nextDir = {x:-1, y:0};
if (key === 'ArrowRight' && gameState.dir.x === 0) gameState.nextDir = {x:1, y:0};
}

// ---- Advanced touch control (angle based like reference game) ----
let touchStart = { x: 0, y: 0 };
let touchActive = false;
// Smaller = more sensitive (reference uses ~22)
const TOUCH_THRESHOLD = 14;

function handleTouchStart(e) {
if (!gameState.running) return;
const t = e.touches[0];
touchStart.x = t.clientX;
touchStart.y = t.clientY;
touchActive = true;
}

function handleTouchMove(e) {
if (!gameState.running || !touchActive) return;
const t = e.touches[0];
const dx = t.clientX - touchStart.x;
const dy = t.clientY - touchStart.y;
// Allow very small movement
if (Math.sqrt(dx * dx + dy * dy) < TOUCH_THRESHOLD) return;
// Reset origin for continuous turning
touchStart.x = t.clientX;
touchStart.y = t.clientY;
// Angle in degrees (0‚Äì360)
const angle = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
// RIGHT
if ((angle >= 315 || angle < 45) && gameState.dir.x === 0) {
gameState.nextDir = { x: 1, y: 0 };
}
// DOWN
else if (angle >= 45 && angle < 135 && gameState.dir.y === 0) {
gameState.nextDir = { x: 0, y: 1 };
}
// LEFT
else if (angle >= 135 && angle < 225 && gameState.dir.x === 0) {
gameState.nextDir = { x: -1, y: 0 };
}
// UP
else if (angle >= 225 && angle < 315 && gameState.dir.y === 0) {
gameState.nextDir = { x: 0, y: -1 };
}
}

function handleTouchEnd() {
touchActive = false;
}

// Mute
function toggleMute() {
gameState.muted = !gameState.muted;
document.getElementById('muteBtn').textContent = gameState.muted ? 'üîá' : 'üîä';
localStorage.setItem('rizznake_muted', gameState.muted ? '1' : '0');
}

function loadMuteState() {
gameState.muted = localStorage.getItem('rizznake_muted') === '1';
document.getElementById('muteBtn').textContent = gameState.muted ? 'üîá' : 'üîä';
}

// Bind
function bindEvents() {
window.addEventListener('keydown', handleKey);
document.addEventListener('touchstart', handleTouchStart, { passive: false });
document.addEventListener('touchmove', handleTouchMove, { passive: true });
document.addEventListener('touchend', handleTouchEnd, { passive: true });
document.getElementById('muteBtn').addEventListener('click', toggleMute);
}

// Start
window.addEventListener('load', init);
</script>
</body>
</html>
